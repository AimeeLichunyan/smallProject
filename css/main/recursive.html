<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<style>
    ul {
   position: absolute;
    width: 200px;
    height: 200px;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
}
/*画3个圆代表红绿灯*/

ul>li {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    opacity: 0.2;
    display: inline-block;
}
/*执行时改变透明度*/

ul.red>#red,
ul.green>#green,
ul.yellow>#yellow {
    opacity: 1.0;
}
/*红绿灯的三个颜色*/

#red {
    background: red;
}

#yellow {
    background: yellow;
}

#green {
    background: green;
}

</style>
<body>
    <div>
            <ul id="traffic" class="">
                    <li id="green"></li>
                    <li id="yellow"></li>
                    <li id="red"></li>
                </ul>
    </div>
    <script>
            // 2019-08-01 学习递归
            function fn(n) {
                if(n == 1) {
                    return 1;
                }
                return n * fn(n-1)
            }
            console.log(fn(5))


            var removeDuplicates = function(S) {
                
                var ss = S.split('');
                for(let i = 0; i <ss.length; i++) {
                        if(ss.length <= 1) {
                            break;
                        }
                        if(ss[i] == ss[i+1]) {
                            ss.splice(i,2);
                            i = i-2;
                        }
                    }
                   let result = ss.join('')
                    // removeDuplicates(ss.join(''))
                    return result;
                    console.log('最后的',result)
            };
            removeDuplicates("abbaca");

            var addToArrayForm = function(A, K) {
                var arrNum = A.join('')
                console.log('arrNum',arrNum)
                var addNum = arrNum + K;
                console.log(addNum)
                return addNum.toString().split('')
            };
            // addToArrayForm([1,2,6,3,0,7,1,7,1,9,7,5,6,6,4,4,0,0,6,3],516)

            // 判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。
            var isPalindrome = function(x) {
                var xString = x.toString();
                var newX = xString.split('').reverse().join('');
                console.log(newX)
                if(xString == newX) {
                    console.log(xString == newX)
                return true
                }else {
                    return false
                }
            };
            // isPalindrome(121)
            

            var romanToInt = function(s) {
                var obj = {
                    I: 1,
                    II: 2,
                    III: 3,
                    IV: 4,
                    V: 5,
                    VI: 6,
                    VII: 7,
                    VIII: 8,
                    IX: 9,
                    X: 10,
                    L:50,
                    C:100,
                    D: 500,
                    M: 1000,
                }
                console.log(obj[s])
                if(obj[s]) {
                    return obj[s]
                }else {
                    var newS = s.split('');
                    var num = 0
                    for (item of newS) {
                        num += obj[item]
                    }
                    console.log(num)
                }
            };
            // romanToInt('MCMXCIV')

            // 编写一个函数来查找字符串数组中的最长公共前缀。

            // 如果不存在公共前缀，返回空字符串 ""。
            var longestCommonPrefix = function(strs) {
            var current = strs[0];
            var num = 0; //计数器，记录有多少个
            for(let i = 1; i < strs.length; i++) {
                console.log(strs[i])
                for(var j = 0; j < current.length; j++) {
                    console.log(current.charAt(j))
                    console.log(strs[i].charAt(j))
                    if(current.charAt(j) != strs[i].charAt(j)) {
                        break;
                    }else {
                        num += 1
                    }
                }
                console.log('num',num)
                    current = current.substring(0, j);
                    console.log('current',current)
            }
            
            // longestCommonPrefix(strs)
        };
        // longestCommonPrefix(["flower","flow","flight"])
        // 给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。
        var removeElement = function(nums, val) {
           for(let i = 0; i < nums.length; i++) {
               if(nums.indexOf(val) > -1) {
                   console.log(nums.indexOf(val))
                   nums.splice(nums.indexOf(val),1);
                   i--;
               }
           }
            return nums.length
        };
        // console.log(removeElement([3,3],3))

        // 给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。
        var strStr = function(haystack, needle) {
            var hayArr = haystack.split('');
            var needleArr = needle.split('');
            // var needTwo = needleArr[0]
            for(let i = 0; i < hayArr.length; i++) {
                if(hayArr.indexOf(needTwo) > -1) {
                    return hayArr.indexOf(needTwo)
                }
            }
            return -1
        };
        // strStr('aaaaa','bba')
        
        // var searchInsert = function(nums, target) {
        //    for(let i = 0; i < nums.length; i++) {
        //        if(nums.indexOf(target) > -1) {
        //            console.log(nums.indexOf(target))
        //            return nums.indexOf(target)
        //        }else if(nums[i] <= target && nums[i+1] >= target ) {
        //            nums.splice(i+1, 0, target)
        //            console.log(nums.indexOf(target))
        //            return nums.indexOf(target)
        //        }else if(i == nums.length-1 && nums[nums.length-1] < target) {
        //           nums.splice(i+1, 0, target)
        //        }else if(i== 0 && nums[0] > target) {
        //            return 0
        //        }
        //    }
        // };
        // searchInsert([1,3,5,6], 0)
        // 方法一 遍历
        // var searchInsert = function (nums, target) {
        //     if (target<nums[0]) return 0
        //     for (var i = 0; i<nums.length;i++){
        //         if (nums[i]>=target) return i;
        //     }
        //     return i
        // };
        // searchInsert([1,3,5,6], 0)
        // console.log(searchInsert([1,3,5,6], 5))
        // 方法二： 遍历
        // var searchInsert = function (nums, target) {
        //     var index = nums.indexOf(target)
        //     if ( index != -1) return index
        //     nums.sort(function (a, b) {// sort 对数字排序是对字符串的排序，如果想对数字排序，就要写个排序函数
        //         console.log(a-b)
        //         return a - b
        //     })
        //     return nums.indexOf(target)
        // };
        // console.log(searchInsert([1,3,5,6], 0))
        // 方法三： 二分法
        var searchInsert = function (nums, target) {
           var left = 0;
           var right = nums.length - 1;
           if(target > nums[right]) {
               return right+1          
            }
            while(left < right) {
                var index = parseInt(left + right) / 2
                if(nums[index] < target) {
                    left = index + 1;
                }else {
                    right = index;
                }
            }
            return left;
        };
        // console.log(searchInsert([1,3,5,6], 0))
        // 将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。
        var mergeTwoLists = function(l1, l2) {
            // var l1Arr = l1.split('->');
            // var l2Arr = l2.split('->');
            // var arr = l1Arr.concat(l2Arr);
            // arr.sort(function(a,b) {
            //     return a-b
            // })
            // return arr.join('->')
            var arr = l1.concat(l2);
            arr.sort(function(a,b) {
                return a-b
            })
            return arr.join('->')
        };
        // console.log(mergeTwoLists('1->2->4', '1->3->4'))

        var lengthOfLongestSubstring = function(s) {
            var max = 0; // 存放没有重复字符串的最大长度
            var index = 0; // 存放当前没有重复子串的开始索引
            var length = s.length;
            var i = 1; // 当前所在的索引
            var j = index; // 大于等于index 小于i
            if(length === 1) {
                return 1;
            }
            while (i < length) {
                if(s[i] === s[j]) {
                    index = j +1;
                    i++;
                    j = index;
                    max = max > (i - index) ? max : (i-index);
                    continue;
                }
                if(j + 1 != i) {
                    j++
                }else {
                    i++;
                    j = index;
                    max = max > (i - index) ? max : (i-index)
                }
            }
            console.log(max)
            return max;
        };
        // lengthOfLongestSubstring('baaabbbbb')

        // 学习promise
        // 每隔1秒钟输出递增的数字，如( 1, 2, 3 等 )
        function next(n) {
            return new Promise(function(res,rej) {
                setTimeout(function() {
                    res(n)
                },1000)
            })
        }
        // next(1).then(function(res) {
        //     console.log(res)
        //     return next(2)
        // }).then(function(res) {
        //     console.log(res)
        //     return next(3)
        // }).then(function(res) {
        //     console.log(res)
        // })

        // next(1).then(function(res) {
        //     console.log(res)
        //     return 2
        // }).then(function(res) {
        //     console.log(res)
        //     return 3
        // }).then(function(res) {
        //     console.log(res)
        // })
        // 示列2：
        // function next() {
        //     return new Promise(function(res,rej) {
        //         var num = Math.floor(Math.random() * 10);
        //         if(num <= 5) {
        //             res(num)
        //         }else {
        //             console.log(num)
        //             rej(new Error())
        //         }
        //     })
        // }

        // next(1).then(function(res) {
        //     console.log(res)
        // },function(res) {
        //     console.log(res)
        // })
        // 当随机数大于等于6的时候，我把一个错误往下抛，然后在then的第二个参数接收到，整个程序还是能够正常运行.
        // console.log('正常执行')
        // 实例3： carch也是接受reject传递的数据
        // function next() {
        //     return new Promise(function(res,rej) {
        //         var num = Math.floor(Math.random() * 10);
        //         if(num <= 5) {
        //             res(num)
        //         }else {
        //             rej(new Error())
        //         }
        //     })
        // }
        // next().then(function(res) {
        //     console.log(res);
        // }).catch(function(res) {
        //     console.log('rej' + res)
        // })
        // console.log('正常执行')
        // promise.all是等所有的异步资源都加载完毕后，在执行的代码，就是那个最慢的异步操作执行完了，在打印结果
        // var count = 0;
        // function next() {
        //     return new Promise((res,rej) => {
        //         var num = Math.floor(Math.random() * 10);
        //         setTimeout(function() {
        //             console.log(num);
        //             res(`第${++count}随机到的值是${num}`);
        //         },1000)
        //     })
        // }
        // Promise.all([next(),next(),next(),next()]).then(function(res) {
        //     console.log(res)
        // })
        // Promise.race，只要最快的异步执行完毕之后，就执行then，不会等待其他的异步操作

        // promise实现红绿灯
        function timeOut (timer) {
            return function() {
                return new Promise(function(res,rej) {
                    setTimeout(res,timer)
                })
            }
        }
    var green = timeOut(3000);
    var yellow = timeOut(4000);
    var red = timeOut(5000);
    var traffic = document.getElementById('traffic');
    (function restart() {
        'use strict' //严格模式
        traffic.className = 'green'
        green().then(function() {
            traffic.className = 'yellow';
            return yellow()
        }).then(function() {
            traffic.className = 'red';
            return red()
        }).then(function() {
            restart()
        })
    })()
    </script>
</body>
</html>