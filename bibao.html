<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>闭包练习</title>
</head>
<body>
    <script>
        class Product {
            constructor(name) {
                this.name = name;
            }
            init() {
                // alert('init')
            }
            fun1() {
                // alert('fun1')
            }
            fun2() {
                // alert('fun2')
            }
        }
        // 工厂
        class Creator {
            create(name) {
                return new Product(name)
            }
        }
        // 创建一个工厂的实例
        var creator = new Creator();
        var p = creator.create('p1');
        p.init()
        p.fun1()

        class jQuery {
            constructor(selector) {

            }
            append() {

            }
            addClass() {

            }
            html(data) {

            }
        }
        window.$ = function(selector) { // 最外层的函数是一个工厂，相当于这个工厂封装了返回实例的操作
            return new jQuery(selector)
        }

        // 单例模式
        // class singleObject {
        //     login() {
        //         console.log('login...')
        //     }
        // }
        // singleObject.getInstance = (function() {
        //     let instance;
        //     return function() {
        //         if(!instance) {
        //             instance = new singleObject();
        //         }
        //         return instance;
        //     }
        // })()
        // let obj1 = singleObject.getInstance();
        // obj1.login();
        // let obj2 = singleObject.getInstance();
        // obj2.login();
        // console.log('obj1===obj2',obj1===obj2) // true
        // console.log('obj1===obj3',obj1===obj3) // false

        // if(window.jQuery !== null) {
        //     return window.jQuery
        // }else {
        //     初始化
        // }
            // class LoginForm {
            //     constructor() {
            //         this.state = 'hide'
            //     }
            //     show() {
            //         if(this.state === 'show') {
            //             alert('已经显示');
            //             return 
            //         }
            //         this.state = 'show';
            //         console.log("登录框显示成功");
                    
            //     }
            //     hide() {
            //         if(this.state === 'hide') {
            //             alert('已经隐藏');
            //             return 
            //         }
            //         this.state = 'show';
            //         console.log("登录框隐藏");
            //     }
            // }
            // LoginForm.getInstance = (function() {
            //     let instance;
            //     return function() {
            //         if(!instance) {
            //             instance = new LoginForm();
            //         }
            //         return instance;
            //     }
            // })()

        // console.log(fn2(6))

// function Promise (excecutor) {
//     // 需要的变量
//     let self = this;
//     self.status = 'pending';
//     self.value = undefined; // 默认成功的值
//     self.reason = undefined; // 默认失败的原因
//     self.onResolvedCallbacks = [];
//     self.onRejectedCallbacks = [];
//     // 成功的回调函数
//     function resolve(value) {
//         if(self.status === 'pending') {
//             self.status = 'resolved';
//             self.value = value;
//             self.onResolvedCallbacks.forEach(function(fn) {
//                 fn()
//             })
//         }
//     }
//     // 失败的回调函数
//     function reject(reason) {
//         if(self.status === 'pending') {
//             self.status = 'rejected';
//             self.reason = reason;
//             self.onRejectedCallbacks.forEach(function(fn) {
//                 fn()
//             })
//         }
//     }
//     try{
//         excecutor(resolve,reject);
//     }catch(e) {
//         reject(e)
//     }
// }

// Promise.prototype.then = function(onFulfiled,onRjected) {
//     onFulfiled = typeof onFulfiled === 'function' ? onFulfiled : function(value) {
//         return value
//     }
//     onRjected = typeof onRjected === 'function' ? onRjected : function(err) {
//         throw err;
//     }
//     let self = this;
//     let promise2;
//     if(self.status == 'resolved') {
//         promise2 = new Promise(function(resolve,reject) {
//             setTimeout(function() {
//                 try{
//                     let x = onFulfiled(self.value);
//                     resolvePromise(promise2,resolve,reject)
//                 }catch(e) {
//                     reject(e)
//                 }
//             })
//         })
//     }
//     if(self.status == 'rejected') {
//         promise2 = new Promise(function(resolve,reject) {
//             let x = onRjected(self.reason)
//             resolvePromise(promise2,resolve,reject)
//         })
//     }
//     if(self.status === 'pending') {
//         promise2 = new Promise(function(resolve,reject) {
//             self.onResolvedCallbacks.push(function() {
//                 let x = onFulfiled(self.value);
//                 resolvePromise(promise2,x,resolve,reject)
//             })
//             self.onRejectedCallbacks.push(function() {
//                 let x = onRjected(self.reason)
//             })
//         })
//     }
//     return promise2
// }
// Promise.all = function(promises) {
//     return new Promise(function(resolve,reject) {
//         for(let i = 0; i < promises.length; i++) {
//             let arr = [];
//             let indexi = 0;
//             function processDate(index,y) {
//                 arr[index] = y;
//                 if(++indexi === promises.length) {
//                     resolve(arr)
//                 }
//             }
//             promises[i].then(function(y) {
//                 processDate(i,y)
//             },reject)
//         }
//     })
// }

//         Promise.race = function(promises) {
//             return new Promise(function(resolve,reject) {
//                 for(let i = 0; i < promises.length; i++) {
//                     promises[i].then(resolve,reject)
//                 }
//             })
//         }

//         Promise.resolve = function(value) {
//             return new Promise(function(resolve,reject) {
//                 resolve(value)
//             })
//         }

//         Promise.reject = function(reson) {
//             return Promise(function(resolve,reject) {
//                 resolve(reason)
//             })
//         }

// const PENDING = 'pending';
// const RESOLVED = 'resolved';
// const REJECTED = 'rejected';

// function MyPromise(fn) {
//     const that = this;
//     that.state = PENDING;
//     that.value = null;
//     that.resolvedCallbacks = [];
//     that.rejectedCallbacks = [];
//     function resolve(value) {
//         if(that.state === PENDING) {
//             console.log(111)
//             that.value = value;
//             that.resolvedCallbacks.map(cb => {
//                 cb(that.value)
//                 console.log(that.value)
//             })
//         }
//     }
//     function reject(value) {
//         if(that.state === PENDING ) {
//             that.state = REJECTED;
//             that.value = value;
//             that.rejectedCallbacks.map(cb=> cb(that.value))
//         }
//     }
//     try{
//         fn(resolve,reject)
//     }catch(e) {
//         reject(e)
//     }
// }
// MyPromise.prototype.then = function(onFulfiled,onRjected) {
//     const that = this;
//     onFulfiled = typeof onFulfiled === 'function' ? onFulfiled : v => v;
//     onRjected = typeof onRjected === 'function' ? onRjected : r => { throw r};
//     if(that.state === PENDING) {
//         that.resolvedCallbacks.push(onFulfiled)
//         that.rejectedCallbacks.push(onRjected)
//     }
//     if(that.state === RESOLVED) {
//         console.log(onFulfiled)
//         onFulfiled(that.value)
//     }
//     if(that.state === REJECTED) {
//         onRjected(that.value)
//     }
// }

// let mypromise = new MyPromise((resove,reject) => {
//     setTimeout(() => {
//         resove(1)
//     },1000)
//     // reject('你错了')
// })
// mypromise.then(value => {
//     console.log(value)
// })

// function test(person) {
//     person.age = 26;
//     person = {
//         name: 'yyy',
//         age: 30,
//     }
//     return person
// }
// const p1 = {
//     name: 'yyy2',
//     age: 25
// }
// const p2 = test(p1);
// console.log(p1);
// console.log(p2)

// let a = {
//     b: 1,
// }
// console.log(a)
// function Person(name) {
//     this.name = name
// }
// let p = new Person('Tom');
// console.log(p.__proto__);
// console.log(Person.__proto__);

// var foo = {},
//     F = function(){};
// Object.prototype.a = 'value a';
// Function.prototype.b = 'value b';

// console.log(foo.a);
// console.log(foo.b);

// console.log(F.a);
// console.log(F.b);

// function Person(name) {
//     this.name = name;
// }
// Person.prototype = {
//     getName() {
//         console.log(this.name)
//     }
// }
// let person = new Person('lili');
// person.getName()
// console.log(Person.prototype.__proto__) // Object.prototype 

//             let login1 = LoginForm.getInstance();
//             login1.show();
//             let login2 = LoginForm.getInstance();
//             login2.show()
//             console.log('login1===login2',login1===login2) // true
console.log('====bind======')
var obj = {};
console.log(obj);
console.log(typeof Function.prototype.bind)
console.log(typeof Function.prototype.bind())
console.log(Function.prototype.bind.name)
console.log(Function.prototype.bind().name)

console.log('=====this的指向问题=====');
var name = "lili"
var a = {
    name : 'A',
    fn: function() {
        console.log(this);
        console.log(this.name)
        
    }
}
a.fn();
a.fn.call({name: 'B'});
var fn1 = a.fn;
fn1();
console.log('=====作用域=====')
if(true) {
    var name = 'lili';
}
console.log(name);

console.log('=====发布订阅模式=======');

class Subject {
    constructor() {
        this.state = 0;
        this.observers = [];
    }
    // 获取值
    getState() {
        return this.state;
    }
    // 设置值
    setState(state) {
        this.state = state;
        this.notifyAllObservers();
    }
    // 通知观察者
    notifyAllObservers() {
        this.observers.forEach(observer => {
            observer.update()
        })
    }
    // 添加观察者
    attach(observer) {
        this.observers.push(observer)

    }
}

// 观察者
class Observer {
    constructor(name,subject) {
        this.name = name;
        this.subject = subject;
        console.log(this)
        this.subject.attach(this)
    }
    // 更新
    update() {
        console.log(`${this.name}update;state:${this.subject.getState()}`);
        
    }
}
// 测试
let s = new Subject();
let o1 = new Observer('o1',s);
let o2 = new Observer('o2',s);
let o3 = new Observer('o3',s);
// o1.update()
s.setState(3)
console.log(Subject.prototype);
console.log(s.__proto__)
// 构造函数
function person() {

}
console.log('dshf')
console.log(person.prototype);

// $('#btn').click(function() {
//     console.log(1)
// })
// $('#btn').click(function() {
//     console.log(2)
// })
let object = {
    name: 'nan'
}
console.log('---')
console.log(object.prototype)
// 最小路径和
// 动态规划-- 120题
var minimumTotal = function(triangle) {
    let num = 0
    let arr = new Array(triangle.length+1).fill(1)
    for(let i = triangle.length - 1; i >= 0; i--) {
        num += Math.min(triangle[i])
    }
    return num
};
/**
 * @param {number[][]} triangle
 * @return {number}
 */
 var minimumTotal = function(triangle) {
    for(var i = triangle.length-2;i >= 0;i--){
        for(var j = 0;j < triangle[i].length;j++){
            triangle[i][j] = Math.min(triangle[i+1][j],triangle[i+1][j+1]) + triangle[i][j];
        }
    }
    return triangle[0][0];
};
// minimumTotal([[-1],[2,3],[1,-1,-3]])
// 正整数的最大乘积  343
console.log('动态规划')
var integerBreak = function(n) {
    const arr = new Array(n+1).fill(1);
    for(let i = 3; i <= n; ++i) {
        for(let j = 1; j< i; ++j) {
            console.log(arr[i])
            arr[i] = Math.max(arr[i],j * (i - j), j * arr[i - j]) // ??????
        }
    }
    
    return arr[n]
};
// integerBreak(4)
var numSquares = function(n) {
    let arr = new Array(n+1).fill(Infinity); // 存最少个数的
    arr[1] = 1
    for(let i = 1; i <= n; i++) {
        
        for(j = 1; Math.pow(j,2) <= i; j++) {
            arr[i] = Math.min(arr[i], arr[i-Math.pow(j,2)]+1)
        }
    }
    return arr[n]
};
numSquares(12)

// 原型继承
console.log('原型继承')
function Person(name) {
    this.name = name;
    this.classname = 'personkkk'
}
Person.prototype.getState = function() {
    console.log(this.name)
}
function Man() {

}
Man.prototype = new Person('我是哈哈哈哈');
var man = new Man();
// console.log(new Man())
// man.getState()
// 构造函数继承
console.log('构造函数继承')
function Person(name) {
    this.name = name;
    this.classname = 'nihay'
}
Person.prototype.getState = function() {
    console.log(this.name)
}
function people(jj) {
    console.log('woshi')
}
function Man(name) {
    Person.call(this,name)
}
let man1 = new Man('hh');
let man2 = new Man('hhhh')
man1.getState();
man2.getState()
console.log(man2.name)

// 组合继承
function Person(name) {
    this.name = name;
    this.classname = 'xixiix'
}
Person.prototype.getState = function() {
    console.log(this.name)
}
function Man() {
    Person.apply(this,arguments)
}
Man.prototype = new Person();
let man3 = new Man('xiaozi ')
man3.getState();
let man4 = new Man('huahua')
man4.getState()

// 寄生式继承
console.log('寄生式继承')
function Person(name) {
    this.name = name;
    this.classname = 'classname'
}
Person.prototype.getState = function() {
    console.log(this.name)
}
function Man() {
    Person.apply(this,arguments)
}
Man.prototype = Object.create(Person.prototype);
let man5 = new Man('huhuhu');
man5.getState();
    </script>
</body>
</html>